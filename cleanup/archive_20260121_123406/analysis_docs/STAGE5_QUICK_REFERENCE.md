# Stage 5 Deployment Wrapper - Quick Reference

## What Gets Generated

```
deployment/                          # ← Single parameterized deployment template
  main.tf / main.bicep              # Calls Stage 4 modules
  variables.tf / parameters.bicep   # User inputs
  outputs.tf / outputs.bicep        # Deployment outputs
  terraform.tfvars.example          # Example parameter values
  main.bicepparam.example           # (for Bicep)
  backend.tf / backend config       # State management
  providers.tf / provider config    # Azure provider
  README.md                         # Deployment guide

modules/naming/                      # ← CAF naming module (generated in Stage 5)
  main.tf / main.bicep              # Naming logic
  variables.tf / parameters.bicep   # Inputs (workload, env, location)
  outputs.tf / outputs.bicep        # Name outputs (one per service)
  README.md                         # Naming documentation
  validate-names.ps1 / .sh          # Uniqueness validation script
```

## Key Instruction Sections (YAML)

| Section | Lines | Purpose |
|---------|-------|---------|
| `deployment_wrapper_agent` | 4595-7000+ | Agent metadata and instructions |
| `terraform_instructions` | 4600-6200 | Terraform deployment generation |
| `bicep_instructions` | 6200-7000+ | Bicep deployment generation |
| Naming module instructions | 4700-5600 | CAF naming module generation |
| Environment template instructions | 5600-6200 | Deployment orchestration |

## Agent Methods (Python)

### Primary Method
```python
async def generate_deployment_wrapper(
    phase1_outputs: Dict[str, Path],      # Phase 1 JSON files
    module_mappings: List[Dict],           # Stage 3 module mappings
    output_dir: Path,                      # IaC root directory
    progress_callback: Optional[Callable]
) -> DeploymentWrapperResult
```

### Internal Methods
```python
_generate_naming_module()        # Step 1: Generate naming module
_generate_environment()          # Step 2: Generate deployment template
_build_naming_module_prompt()    # Construct naming prompt from Phase 1
_build_environment_prompt()      # Construct deployment prompt
_parse_json_response()           # Parse JSON with 3 fallback strategies
_load_phase1_outputs()           # Load Phase 1 analysis files
```

## Prompt Construction Flow

### 1. Naming Module Prompt

```
[YAML Template: deployment_wrapper_naming_module]
    ↓
[Extract from Phase 1]:
  - All resource types
  - Resource counts
  - Naming constraints
    ↓
[Research Instructions]:
  - Bing: CAF abbreviations
  - Bing: Service naming constraints
  - MS Learn: Official naming rules
    ↓
[Format into prompt]
    ↓
[Send to Agent]
```

### 2. Deployment Template Prompt

```
[YAML Template: deployment_wrapper_environment_{terraform|bicep}]
    ↓
[Extract from Phase 1]:
  - Security recommendations
  - Network topology
  - RBAC assignments
  - Monitoring config
    ↓
[Extract from Stage 3]:
  - Module mappings
  - Module paths
    ↓
[Format into prompt]
    ↓
[Send to Agent]
```

## Phase 1 Data Application

### Security (from `rbac_assignments.json`)
```hcl
# Extracted automatically
managed_identities = { system_assigned = true }  # Phase 1 recommendation
disable_local_auth = true                        # Phase 1 recommendation
customer_managed_key = {...}                     # If Phase 1 recommended CMK

role_assignments = {
  # Phase 1 RBAC assignments applied here
}
```

### Network (from `network_flows.json`, `private_endpoints.json`)
```hcl
# Extracted automatically
public_network_access_enabled = false  # Phase 1 recommendation
private_endpoints = {
  # Phase 1 private endpoint topology
}
```

### Monitoring (from Phase 1 analysis)
```hcl
# Extracted automatically
diagnostic_settings = {
  default = {
    log_analytics_workspace_id = var.log_analytics_workspace_id
    log_categories = ["Audit", "RequestResponse"]  # Phase 1 recommended
    metric_categories = ["AllMetrics"]
  }
}
```

## Naming Module Generation Logic

### CAF Abbreviations (Research-Based)
```hcl
locals {
  abbreviations = {
    "storage_account"    = "st"     # Research: Bing + MS Learn
    "key_vault"          = "kv"
    "cognitive_services" = "cog"
    # ... ALL detected services
  }
}
```

### Constraint Enforcement
```hcl
output "storage_account_name" {
  # 3-24 chars, lowercase alphanumeric ONLY, globally unique
  value = substr(
    lower(replace("st${workload}${env}${loc}${suffix}", "/[^a-z0-9]/", "")),
    0,
    24
  )
}

output "key_vault_name" {
  # 3-24 chars, alphanumeric + hyphens, globally unique
  value = substr("kv-${workload}-${env}-${loc}${suffix}", 0, 24)
}
```

### Uniqueness Validation Script
```powershell
# validate-names.ps1 (generated by agent)

# Build names using same logic as naming module
$storageAccountName = "st${workloadName}${envAbbr}${locAbbr}${suffix}"

# Check Azure for uniqueness
az storage account check-name --name $storageAccountName

# Report availability or conflicts
```

## Module Call Pattern

### Terraform
```hcl
module "cognitive_services" {
  source = "../modules/cognitive-services-account"  # Stage 4 module
  
  name     = module.naming.cognitive_services_account_name  # From naming module
  location = var.location
  
  # Phase 1 security recommendations
  managed_identities = { system_assigned = true }
  disable_local_auth = true
  
  # Phase 1 network recommendations
  public_network_access_enabled = false
  private_endpoints = { ... }
  
  # Phase 1 monitoring recommendations
  diagnostic_settings = { ... }
  
  # Phase 1 RBAC recommendations
  role_assignments = { ... }
}
```

### Bicep
```bicep
module cognitiveServices '../modules/cognitive-services-account/main.bicep' = {
  name: 'cognitive-services-deployment'
  params: {
    name: naming.outputs.cognitiveServicesAccountName  // From naming module
    location: location
    
    managedIdentities: { systemAssigned: true }  // Phase 1 recommendation
    disableLocalAuth: true
    publicNetworkAccessEnabled: false
    privateEndpoints: { ... }
    diagnosticSettings: { ... }
    roleAssignments: { ... }
  }
}
```

## Expected JSON Response Format

### Naming Module
```json
{
  "files": {
    "main.tf": "# Naming logic...",
    "variables.tf": "# Inputs...",
    "outputs.tf": "# Name outputs for ALL services...",
    "README.md": "# Documentation...",
    "validate-names.ps1": "# Validation script..."
  },
  "caf_compliant": true,
  "services_covered": [
    "Microsoft.Storage/storageAccounts",
    "Microsoft.KeyVault/vaults",
    "Microsoft.CognitiveServices/accounts"
  ]
}
```

### Deployment Template
```json
{
  "files": {
    "main.tf": "# Module orchestration...",
    "variables.tf": "# User inputs...",
    "outputs.tf": "# Deployment outputs...",
    "terraform.tfvars.example": "# Example values...",
    "backend.tf": "# State config...",
    "providers.tf": "# Provider config...",
    "README.md": "# Deployment guide..."
  },
  "required_user_inputs": [
    {
      "name": "subscription_id",
      "description": "Azure subscription ID",
      "type": "string",
      "required": true
    }
  ],
  "phase1_recommendations_applied": {
    "security": ["Managed identities enabled", "Local auth disabled"],
    "network": ["Private endpoints configured"],
    "monitoring": ["Diagnostic settings enabled"]
  }
}
```

## Key Design Decisions

### 1. Single Deployment (Not 3 Environments)
**Before**: `environments/dev/`, `environments/staging/`, `environments/prod/`  
**Now**: `deployment/` with parameterized environment selection

**Rationale**:
- Reduces code duplication
- Easier environment promotion
- Modern IaC best practices
- Users specify env at deployment time

### 2. Naming Module in Stage 5 (Not Stage 4)
**Why Stage 5?**
- Requires knowledge of ALL services
- Needs Phase 1 constraint data
- Must validate global uniqueness
- Deployment-specific (uses workload name)

### 3. Research-Driven Naming
**Not hardcoded templates**:
- Bing: CAF abbreviations
- Bing: Service constraints
- MS Learn: Official docs
- Phase 1: Custom constraints

### 4. Automatic Phase 1 Application
**No manual translation**:
- Agent extracts recommendations
- Converts to module parameters
- Applies security hardening
- Configures network isolation
- Sets up monitoring

## Token Limits and Handling

### Naming Module
```python
run = client.runs.create_and_process(
    thread_id=thread.id,
    agent_id=agent.id,
    max_completion_tokens=16000  # Increased for complete naming module
)

# Log token usage
if run.usage.completion_tokens >= 15500:
    logger.warning("⚠️ Near token limit! May be truncated.")
```

### Deployment Template
```python
# Standard token limit
run = client.runs.create_and_process(
    thread_id=thread.id,
    agent_id=agent.id,
    max_completion_tokens=8000
)
```

## Debugging Features

### JSON Parsing Failures
```python
# If parsing fails, saves raw response
debug_path = env_base.parent / f"_debug_{env_name}_response.txt"
debug_path.write_text(response_text, encoding="utf-8")
logger.error(f"Raw response saved to: {debug_path}")
```

### Missing Files
```python
if not env_data.get("files"):
    logger.error("No files generated!")
    logger.error(f"Response keys: {list(env_data.keys())}")
    # Save for analysis
```

## Common Issues & Solutions

### Issue: Name Conflicts
**Solution**: Run `validate-names.ps1` before deployment
```bash
./validate-names.ps1 -WorkloadName "contoso" -Environment "dev" -Location "eastus" -ResourceSuffix "abc1"
```

### Issue: Missing Phase 1 Data
**Solution**: Ensure Phase 1 outputs exist
```python
phase1_outputs = {
    "architecture_analysis": Path("outputs/phase1/architecture_analysis.json"),
    "rbac_assignments": Path("outputs/phase1/rbac_assignments.json"),
    "network_flows": Path("outputs/phase1/network_flows.json")
}
```

### Issue: Module Not Found
**Solution**: Verify Stage 4 modules generated first
```bash
ls modules/
# Should show:
# cognitive-services-account/
# storage-account/
# key-vault/
# network-privateendpoints/
# etc.
```

## Testing the Output

### 1. Validate YAML Syntax
```python
import yaml
with open("synthforge/prompts/iac_agent_instructions.yaml") as f:
    data = yaml.safe_load(f)
    assert "deployment_wrapper_agent" in data
```

### 2. Validate Generated Files
```python
# Check deployment folder
deployment_dir = Path("iac/deployment")
assert (deployment_dir / "main.tf").exists()
assert (deployment_dir / "variables.tf").exists()
assert (deployment_dir / "README.md").exists()

# Check naming module
naming_dir = Path("iac/modules/naming")
assert (naming_dir / "main.tf").exists()
assert (naming_dir / "outputs.tf").exists()
```

### 3. Validate Terraform Syntax
```bash
cd iac/deployment
terraform init
terraform validate
```

### 4. Validate Bicep Syntax
```bash
cd iac/deployment
az bicep build --file main.bicep
```

## Key Metrics

| Metric | Value |
|--------|-------|
| Instructions Lines | 2400+ lines |
| Agent Methods | 15+ methods |
| Token Limit (Naming) | 16,000 |
| Token Limit (Deploy) | 8,000 |
| Phase 1 Inputs | 5+ JSON files |
| Generated Files (Naming) | 5 files |
| Generated Files (Deploy) | 7 files |
| Total Output | ~12 files |

---

*Quick reference for Stage 5 Deployment Wrapper generation*  
*See STAGE5_DEPLOYMENT_ANALYSIS.md for comprehensive details*
